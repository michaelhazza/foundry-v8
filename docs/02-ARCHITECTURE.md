# Technical Architecture Document: Foundry
**Generated by:** Agent 2 - System Architecture v17 (Sonnet Optimized)  
**Date:** 2026-01-19  
**Status:** Complete  
**Framework:** Agent Specification Framework v2.1  
**Constitution:** Agent 0 v3.1

---

## CHECKPOINT 1: Architectural Drivers

### Architectural Drivers

**Primary Business Driver:** Enable non-technical users to prepare AI-ready datasets from heterogeneous data sources in <5 minutes without engineering support.

**Key Quality Attributes (Priority Order):**
1. **Usability** - Non-technical users complete core workflow without documentation
2. **Security** - Privacy-first with automatic PII detection and de-identification
3. **Reliability** - Processing completes successfully 95%+ of time
4. **Performance** - 1000 records processed in <3 minutes
5. **Maintainability** - Single developer can understand and modify system

**Scale Constraints:**
- MVP: 10-50 organizations, 100-500 users
- File size: Up to 100MB per upload
- Processing volume: 1000 records typical, 10,000 max per batch
- Concurrent processing: 5-10 simultaneous jobs

### Hard Constraints (Constitution Section D)

**Replit Platform Non-Negotiables:**
- Port 5000 for production (Replit's exposed port)
- Ephemeral filesystem (no persistent file storage)
- Single container deployment (no microservices)
- Cold start tolerance (app sleeps after inactivity)
- No interactive CLI prompts in build/migration commands
- Managed PostgreSQL database (postgres-js driver required)

**Project Constraints (PRD):**
- Multi-tenant SaaS architecture
- Privacy by design (no PII in processed datasets)
- Source agnostic (files, APIs, databases treated equally)
- Configuration-driven (no code required for users)
- Incremental value (works with single file, scales with more sources)

### Proposed Pattern

**Monolithic Application with Internal Modules**

**Rationale:** Replit's single-container constraint eliminates microservices. Monolith with clear module boundaries provides:
- Simplified deployment (single process)
- Reduced operational complexity (no service mesh)
- Faster development (no distributed system debugging)
- Easier data consistency (single database, no distributed transactions)
- Natural fit for MVP scale (100-500 users)

**Architecture Style:** Three-tier web application with async processing pipeline

**Core Modules:**
1. **API Layer** - Express routes, middleware, auth
2. **Processing Engine** - Data transformation, de-identification, schema mapping
3. **Integration Layer** - File parsing, API connectors
4. **Data Layer** - Drizzle ORM, database access

### Eliminated Technologies

| Technology | Reason for Elimination |
|------------|----------------------|
| Microservices | Replit single-container constraint |
| Redis/External Queue | Unnecessary complexity for MVP scale, prefer in-process queue |
| NoSQL Databases | PRD requires structured schemas, relational data fits PostgreSQL |
| GraphQL | REST sufficient for MVP, GraphQL adds unnecessary complexity |
| WebSockets | Polling simpler for MVP, WebSockets add deployment complexity |
| Docker Compose | Replit provides container, multi-container not needed |
| NextJS | Separate frontend/backend clearer for team structure |

---

## 1. Architectural Overview

### System Context

```
┌─────────────────────────────────────────────────────────────────┐
│                          External World                          │
│                                                                   │
│  ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐   │
│  │  Users   │   │  Email   │   │ Teamwork │   │   File   │   │
│  │ (Browser)│   │ Service  │   │   Desk   │   │ Uploads  │   │
│  └────┬─────┘   └────┬─────┘   └────┬─────┘   └────┬─────┘   │
│       │              │              │              │           │
└───────┼──────────────┼──────────────┼──────────────┼───────────┘
        │              │              │              │
        │              │              │              │
┌───────▼──────────────▼──────────────▼──────────────▼───────────┐
│                      FOUNDRY (Replit)                            │
│                                                                   │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                   React Frontend (Vite)                     │ │
│  │  - shadcn/ui components                                     │ │
│  │  - Tailwind CSS                                             │ │
│  │  - React Query (API state)                                  │ │
│  └────────────────────┬───────────────────────────────────────┘ │
│                       │ HTTP/JSON                                │
│  ┌────────────────────▼───────────────────────────────────────┐ │
│  │              Express.js Backend API                         │ │
│  │                                                              │ │
│  │  ┌─────────────┐  ┌──────────────┐  ┌──────────────┐     │ │
│  │  │   Auth      │  │  Projects    │  │   Sources    │     │ │
│  │  │  Middleware │  │  Controller  │  │  Controller  │     │ │
│  │  └─────────────┘  └──────────────┘  └──────────────┘     │ │
│  │                                                              │ │
│  │  ┌──────────────────────────────────────────────────────┐  │ │
│  │  │          Processing Engine (In-Process)              │  │ │
│  │  │  - File Parser (CSV, JSON, Excel)                    │  │ │
│  │  │  - PII Detector (Regex + Field Heuristics)           │  │ │
│  │  │  - De-identification Engine                          │  │ │
│  │  │  - Schema Mapper                                     │  │ │
│  │  │  - Task Queue (Simple In-Memory)                     │  │ │
│  │  └──────────────────────────────────────────────────────┘  │ │
│  │                                                              │ │
│  │  ┌──────────────────────────────────────────────────────┐  │ │
│  │  │            Data Layer (Drizzle ORM)                  │  │ │
│  │  │  - postgres-js driver                                │  │ │
│  │  │  - Connection pooling                                │  │ │
│  │  └──────────────────────────────────────────────────────┘  │ │
│  └────────────────────┬───────────────────────────────────────┘ │
│                       │                                          │
│  ┌────────────────────▼───────────────────────────────────────┐ │
│  │          PostgreSQL Database (Replit Managed)              │ │
│  │  - Multi-tenant data isolation                              │ │
│  │  - File storage (BYTEA columns)                             │ │
│  │  - Processing state tracking                                │ │
│  └────────────────────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────────────────────┘
```

### Core Pattern

**Three-Tier Monolith with Async Processing**

**Presentation Tier (React SPA):**
- Single-page application built with Vite
- Component library: shadcn/ui
- Styling: Tailwind CSS with CSS variables
- State management: React Query for server state, useState/useContext for UI state
- File handling: Multi-part upload with progress tracking

**Application Tier (Express API):**
- RESTful API endpoints
- JWT-based authentication
- Request validation (Zod schemas)
- In-process task queue for background processing
- Middleware: helmet, cors, rate-limit, morgan

**Data Tier (PostgreSQL):**
- Multi-tenant data model with organization isolation
- File storage in BYTEA columns (ephemeral filesystem constraint)
- Row-level security via ORM filters
- Drizzle ORM with postgres-js driver

### System Boundaries

**In Scope (This System):**
- User authentication and authorization
- Project and source management
- File upload and parsing
- PII detection and de-identification
- Schema mapping configuration
- Background processing pipeline
- Dataset generation and download
- Teamwork Desk API integration
- Email invitation delivery (optional)

**Out of Scope (External Dependencies):**
- Email delivery infrastructure (delegated to SendGrid/Resend)
- File storage infrastructure (contained in database)
- Analytics tracking (Phase 2)
- Advanced ML-based PII detection (Phase 2)
- Real-time collaboration features (Phase 2)

---

## 2. Technology Stack

### Frontend Stack

| Component | Technology | Rationale | Alternatives Considered |
|-----------|-----------|-----------|------------------------|
| **Framework** | React 18 + Vite | De facto standard for interactive UIs; Vite provides fast HMR and optimized builds; extensive ecosystem; team familiarity | Next.js (rejected: SSR unnecessary, prefer clear frontend/backend separation), Vue (rejected: React has better shadcn/ui integration) |
| **Build Tool** | Vite 5 | 10x faster dev server than Webpack; native ESM support; optimized production builds; excellent TypeScript support | Webpack (rejected: slower dev experience), Parcel (rejected: less mature ecosystem) |
| **UI Components** | shadcn/ui | Copy-paste components (no npm dependency); Tailwind-native; Radix primitives for accessibility; full customization control | Material-UI (rejected: heavier bundle), Chakra UI (rejected: different styling paradigm), Custom components (rejected: reinventing wheel) |
| **Styling** | Tailwind CSS 3 | Utility-first rapid development; consistent design system; excellent IDE support; small production bundle via purging | CSS Modules (rejected: more boilerplate), Styled Components (rejected: runtime cost), Sass (rejected: utility-first faster) |
| **State Management** | React Query + Context | React Query for server state (caching, refetching, optimistic updates); Context for UI state; avoids Redux complexity | Redux Toolkit (rejected: overkill for MVP), Zustand (rejected: React Query sufficient for server state), Recoil (rejected: experimental) |
| **Form Handling** | React Hook Form + Zod | Performant uncontrolled forms; Zod for type-safe validation matching backend; minimal re-renders | Formik (rejected: more re-renders), Manual (rejected: validation duplication risk) |
| **HTTP Client** | fetch + React Query | Native fetch API; React Query handles caching, retries, loading states; no extra dependency | Axios (rejected: unnecessary abstraction), SWR (rejected: React Query more feature-complete) |
| **Routing** | React Router 6 | Industry standard; nested routes; lazy loading; URL state management | Wouter (rejected: too minimal), TanStack Router (rejected: too new) |

**Trade-offs:**
- **Gain:** Fast development velocity, excellent DX, type safety, accessible components
- **Sacrifice:** React ecosystem size can be overwhelming, Tailwind requires learning utility classes
- **Justification:** React + Tailwind is the fastest path to production-quality UI for this team; shadcn/ui solves accessibility without restricting customization

### Backend Stack

| Component | Technology | Rationale | Alternatives Considered |
|-----------|-----------|-----------|------------------------|
| **Runtime** | Node.js 20 LTS | JavaScript across stack reduces context switching; mature ecosystem; excellent Replit support; async I/O perfect for I/O-bound workloads | Deno (rejected: newer, less mature ecosystem), Bun (rejected: too new, less tooling), Python (rejected: team is TypeScript-focused) |
| **Framework** | Express.js 4 | Minimal, flexible, battle-tested; excellent middleware ecosystem; clear learning path; no magic | Fastify (rejected: marginal performance gain not worth new patterns), NestJS (rejected: too opinionated, overkill for MVP), Hono (rejected: too new) |
| **Language** | TypeScript 5 | Type safety prevents 40%+ of bugs; superior IDE support; gradual typing allows pragmatism | JavaScript (rejected: loses type safety), compiled language (rejected: deployment complexity) |
| **ORM** | Drizzle ORM | Type-safe SQL; minimal abstraction; excellent performance; postgres-js integration; no magic queries | Prisma (rejected: Constitution requires postgres-js, not Prisma client), TypeORM (rejected: decorator magic), Kysely (rejected: query builder not ORM) |
| **Database Driver** | postgres-js | **Constitution mandated**; fastest PostgreSQL driver; pipeline mode; excellent TypeScript support | pg (rejected: Constitution mandates postgres-js), node-postgres (rejected: same as pg) |
| **Validation** | Zod | Type-safe runtime validation; shared with frontend; excellent error messages; composable schemas | Joi (rejected: no TypeScript inference), Yup (rejected: worse TypeScript support), AJV (rejected: JSON Schema verbose) |
| **Authentication** | JWT + bcrypt | Stateless tokens scale horizontally; bcrypt industry standard for password hashing (cost 12); refresh token pattern for security | Passport.js (rejected: unnecessary abstraction), Session cookies (rejected: stateful, doesn't scale), Auth0 (rejected: vendor lock-in, cost) |
| **Task Queue** | Simple in-process queue | Sufficient for MVP scale (5-10 concurrent jobs); no external dependency; graceful degradation on failure | BullMQ (rejected: requires Redis, overkill for MVP), node-cron (rejected: not task queue), pg-boss (rejected: unnecessary complexity) |
| **File Parsing** | papaparse (CSV), xlsx (Excel) | Battle-tested libraries; handle edge cases; stream processing for large files | csv-parse (rejected: papaparse more forgiving), exceljs (rejected: xlsx simpler API) |

**Trade-offs:**
- **Gain:** Type safety, rapid development, proven patterns, Replit compatibility
- **Sacrifice:** Node.js not fastest runtime, in-process queue limits horizontal scaling
- **Justification:** JavaScript/TypeScript full-stack maximizes velocity; Express + Drizzle is boring technology that works; in-process queue sufficient for MVP, can extract to BullMQ/Redis later if needed

### Infrastructure & Deployment

| Component | Technology | Rationale | Alternatives Considered |
|-----------|-----------|-----------|------------------------|
| **Hosting** | Replit | **Project requirement**; managed PostgreSQL included; zero DevOps overhead; instant deployment | Vercel (rejected: requires separate database), Railway (rejected: not project requirement), AWS (rejected: too complex for MVP) |
| **Database** | PostgreSQL 15 (Replit Managed) | **Constitution mandated**; ACID guarantees; JSONB for flexible schemas; excellent full-text search; BYTEA for file storage | MySQL (rejected: less feature-rich), MongoDB (rejected: PRD requires structured schemas), SQLite (rejected: multi-tenant needs better isolation) |
| **File Storage** | PostgreSQL BYTEA columns | **Replit constraint** (ephemeral filesystem); keeps all data in single system; simplifies backup/restore; transactional consistency | S3-compatible (rejected: adds cost and complexity), Filesystem (rejected: ephemeral on Replit), Cloudflare R2 (rejected: MVP doesn't need it) |
| **Email Delivery** | Resend (OPTIONAL) | Modern API; generous free tier (100 emails/day); excellent DX; compliance-ready | SendGrid (alternative: more mature), Postmark (alternative: transactional focus), SMTP (rejected: reliability issues) |
| **Monitoring** | Console logs + Replit logs | Built-in, zero setup, sufficient for MVP debugging | Sentry (Phase 2), DataDog (rejected: overkill for MVP), LogRocket (Phase 2) |

**Trade-offs:**
- **Gain:** Zero infrastructure management, fast deployment, low cost
- **Sacrifice:** Database file storage may hit performance limits at scale, less control over infrastructure
- **Justification:** Replit constraint is non-negotiable; database file storage acceptable for MVP (100MB max), can refactor to object storage post-MVP if needed

### Development Tools

| Tool | Purpose |
|------|---------|
| TypeScript 5 | Type safety across stack |
| ESLint + Prettier | Code quality and formatting |
| Vitest | Unit and integration testing |
| tsx | TypeScript execution for migrations |
| dotenv | Environment variable loading |

---

## 3. PRD-to-Architecture Traceability

| PRD Feature | Architectural Support | Components Involved |
|-------------|----------------------|---------------------|
| **Multi-tenant SaaS** | Organization-scoped data model; JWT with org_id claim; Row-level filtering in ORM | Auth middleware, Data layer, All models |
| **File upload (CSV, JSON, Excel)** | Multi-part upload endpoint; File parsing modules; BYTEA storage | File upload controller, File parsers, Sources table |
| **PII detection** | Regex-based pattern matcher; Field name heuristics; Detection suggestions in UI | PII detector module, De-identification rules table |
| **De-identification** | Transformation engine (mask, hash, remove, replace); Rule configuration storage | De-identification engine, Rules table, Processing pipeline |
| **Schema mapping** | Drag-and-drop field mapper UI; Mapping storage; Transformation pipeline | Field mappings table, Schema mapper module, Frontend mapping UI |
| **Background processing** | In-process task queue; Job state tracking; Progress polling endpoint | Task queue, Processing jobs table, Processing engine |
| **Real-time progress** | Polling-based progress tracking (2s interval); Job status endpoint | Processing jobs table, Job status API, Frontend polling |
| **Dataset download** | Processed dataset generation; CSV export; Temporary download link | Export controller, File generation, Download links |
| **Teamwork Desk integration** | REST API client; OAuth integration; Ticket fetching | Teamwork connector, API credentials table, Integration layer |
| **User invitations** | Invitation token generation; Email sending (OPTIONAL); Registration with token | Invitations table, Email service, Auth controller |
| **User authentication** | JWT-based auth; Password hashing (bcrypt cost 12); Refresh tokens | Auth middleware, Users table, JWT service |
| **Project management** | Project CRUD; User-project associations; Permission model | Projects table, Project controller, RBAC middleware |
| **Privacy compliance** | PII lineage tracking; Audit logs; De-identification rules | Audit logs table, Processing lineage, Rules metadata |

**Unmapped PRD Elements:**
- **Governance Dashboard** (FEAT-009): Explicitly marked post-MVP in PRD
- **Multi-organization membership** (AR-004): Assumption register item, single org per user for MVP

---

## 4. Component Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                         CLIENT TIER                              │
│                                                                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │   Auth UI    │  │  Project UI  │  │  Source UI   │          │
│  │  - Login     │  │  - Dashboard │  │  - Upload    │          │
│  │  - Register  │  │  - Settings  │  │  - Configure │          │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
│         │                  │                  │                   │
│         └──────────────────┼──────────────────┘                   │
│                            │                                      │
│  ┌─────────────────────────▼────────────────────────┐           │
│  │           API Client (React Query)                │           │
│  │  - Request/response handling                      │           │
│  │  - Caching and revalidation                       │           │
│  │  - Optimistic updates                             │           │
│  └────────────────────────────────────────────────────┘           │
└───────────────────────────┬──────────────────────────────────────┘
                            │ HTTPS/JSON
┌───────────────────────────▼──────────────────────────────────────┐
│                      APPLICATION TIER                             │
│                                                                   │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │                  Express Middleware Stack                   │  │
│  │  ┌──────────┐ ┌──────────┐ ┌───────────┐ ┌────────────┐  │  │
│  │  │  Helmet  │→│   CORS   │→│Rate Limit │→│   Morgan   │  │  │
│  │  └──────────┘ └──────────┘ └───────────┘ └────────────┘  │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                   │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │                    Route Controllers                        │  │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌──────────────┐   │  │
│  │  │  Auth   │ │Projects │ │ Sources │ │ Processing   │   │  │
│  │  │  Routes │ │ Routes  │ │ Routes  │ │   Routes     │   │  │
│  │  └────┬────┘ └────┬────┘ └────┬────┘ └──────┬───────┘   │  │
│  └───────┼───────────┼──────────┼───────────────┼───────────┘  │
│          │           │          │               │               │
│  ┌───────▼───────────▼──────────▼───────────────▼───────────┐  │
│  │                    Business Logic Layer                    │  │
│  │  ┌────────────┐ ┌────────────┐ ┌───────────────────────┐ │  │
│  │  │   Auth     │ │  Project   │ │    Source Service     │ │  │
│  │  │  Service   │ │  Service   │ │  - Validation         │ │  │
│  │  │  - JWT     │ │  - CRUD    │ │  - Configuration      │ │  │
│  │  │  - Hashing │ │  - Perms   │ │                       │ │  │
│  │  └────────────┘ └────────────┘ └───────────────────────┘ │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                   │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │                  Processing Engine                          │  │
│  │  ┌───────────────┐ ┌──────────────┐ ┌─────────────────┐  │  │
│  │  │  Task Queue   │ │File Parsers  │ │ PII Detector    │  │  │
│  │  │  - Enqueue    │ │  - CSV       │ │  - Regex        │  │  │
│  │  │  - Execute    │ │  - JSON      │ │  - Heuristics   │  │  │
│  │  │  - Progress   │ │  - Excel     │ │                 │  │  │
│  │  └───────────────┘ └──────────────┘ └─────────────────┘  │  │
│  │  ┌───────────────┐ ┌──────────────┐ ┌─────────────────┐  │  │
│  │  │Schema Mapper  │ │De-identifier │ │Dataset Generator│  │  │
│  │  │  - Transform  │ │  - Mask      │ │  - Export CSV   │  │  │
│  │  │  - Validate   │ │  - Hash      │ │  - Packaging    │  │  │
│  │  └───────────────┘ └──────────────┘ └─────────────────┘  │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                   │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │                  Integration Layer                          │  │
│  │  ┌─────────────────┐  ┌──────────────────────────────────┐ │  │
│  │  │ Email Service   │  │   Teamwork Desk Connector        │ │  │
│  │  │  - Send (opt)   │  │    - OAuth flow                  │ │  │
│  │  │  - Templates    │  │    - Ticket fetching             │ │  │
│  │  └─────────────────┘  └──────────────────────────────────┘ │  │
│  └────────────────────────────────────────────────────────────┘  │
│                                                                   │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │                     Data Access Layer                       │  │
│  │  ┌──────────────────────────────────────────────────────┐  │  │
│  │  │              Drizzle ORM Repositories                 │  │  │
│  │  │  - Type-safe queries                                  │  │  │
│  │  │  - Transaction management                             │  │  │
│  │  │  - Organization filtering                             │  │  │
│  │  └──────────────────────────────────────────────────────┘  │  │
│  └────────────────────────────────────────────────────────────┘  │
└───────────────────────────┬──────────────────────────────────────┘
                            │ postgres-js
┌───────────────────────────▼──────────────────────────────────────┐
│                          DATA TIER                                │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │                PostgreSQL Database                          │  │
│  │  Tables: users, organizations, projects, sources,          │  │
│  │          processing_jobs, field_mappings, rules,            │  │
│  │          invitations, api_credentials, audit_logs           │  │
│  └────────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────────┘
```

### Responsibility Matrix

| Component | Responsibilities | Dependencies | Scaling Characteristics |
|-----------|------------------|--------------|------------------------|
| **Auth UI** | Login/register forms, token storage, protected routes | API Client | Stateless, scales horizontally |
| **Project UI** | Project CRUD, source listing, dataset management | API Client | Stateless, scales horizontally |
| **Source UI** | File upload, field mapping, de-identification config, progress tracking | API Client | Stateless, scales horizontally |
| **API Client** | HTTP requests, caching, error handling, optimistic updates | React Query | Client-side, N/A |
| **Auth Routes** | POST /auth/register, POST /auth/login, POST /auth/refresh, POST /auth/logout | Auth Service, Users repository | Stateless, rate-limited |
| **Projects Routes** | CRUD on /projects, user permissions | Projects Service, Auth middleware | Stateless, org-scoped |
| **Sources Routes** | POST /sources (upload), GET /sources/:id, POST /sources/:id/process | Sources Service, Processing Engine | Stateless, handles large files |
| **Processing Routes** | GET /processing-jobs/:id (status), GET /processing-jobs/:id/download | Processing Engine, Jobs repository | Stateless, polling endpoint |
| **Auth Service** | Password hashing (bcrypt), JWT signing/verification, refresh token rotation | bcrypt, jsonwebtoken | Stateless, CPU-intensive |
| **Projects Service** | Project validation, CRUD logic, permission checks | Projects repository | Stateless |
| **Sources Service** | Source validation, file validation, config persistence | Sources repository | Stateless |
| **Task Queue** | Job enqueueing, execution, progress tracking, failure handling | Processing Engine | In-memory, single-process |
| **File Parsers** | CSV/JSON/Excel parsing, error handling, stream processing | papaparse, xlsx | CPU/memory intensive |
| **PII Detector** | Regex pattern matching, field name heuristics, suggestion generation | None | CPU-intensive |
| **Schema Mapper** | Field transformation, validation, type coercion | Field mappings | CPU-intensive |
| **De-identifier** | Mask/hash/remove/replace transformations, consistency enforcement | Rules repository | CPU-intensive |
| **Dataset Generator** | CSV generation, file packaging, temporary link creation | None | I/O intensive |
| **Email Service** | Template rendering, email sending (optional), retry logic | Resend API | External dependency |
| **Teamwork Connector** | OAuth flow, ticket fetching, pagination, rate limiting | Teamwork API | External dependency |
| **Drizzle Repositories** | CRUD operations, transactions, org filtering, query optimization | postgres-js | Connection pooled |

### Interface Contracts

**Frontend ↔ Backend API:**
- Protocol: HTTPS + JSON
- Authentication: JWT Bearer tokens in Authorization header
- Response format: Per Constitution Section C (success/error envelopes)
- Error codes: Per Constitution Section C (standardized codes)
- Rate limiting: Headers per Constitution

**Backend ↔ Database:**
- Protocol: PostgreSQL wire protocol via postgres-js
- Connection pooling: Max 10 connections, 20s idle timeout
- Transaction isolation: Read Committed (PostgreSQL default)
- Query interface: Drizzle ORM Core Select API

**Backend ↔ Email Service (OPTIONAL):**
- Protocol: HTTPS + JSON (Resend REST API)
- Authentication: API key in Authorization header
- Retry strategy: 3 attempts with exponential backoff
- Failure mode: Log to console, continue without email

**Backend ↔ Teamwork Desk:**
- Protocol: HTTPS + JSON (Teamwork REST API v3)
- Authentication: OAuth 2.0 (authorization code flow)
- Rate limiting: Respect API rate limits (documented by Teamwork)
- Pagination: Cursor-based or page-based (per Teamwork API docs)

---

## 5. Authentication & Authorization

### Registration Flow

```
User                    Frontend                Backend                 Database
 │                         │                       │                        │
 │  Fill registration form │                       │                        │
 ├────────────────────────►│                       │                        │
 │                         │  POST /auth/register  │                        │
 │                         │  { email, password,   │                        │
 │                         │    name, org_name }   │                        │
 │                         ├──────────────────────►│                        │
 │                         │                       │  Validate input        │
 │                         │                       │  (Zod schema)          │
 │                         │                       │                        │
 │                         │                       │  Check email exists    │
 │                         │                       ├───────────────────────►│
 │                         │                       │◄───────────────────────┤
 │                         │                       │  Not found (OK)        │
 │                         │                       │                        │
 │                         │                       │  Hash password         │
 │                         │                       │  (bcrypt cost 12)      │
 │                         │                       │                        │
 │                         │                       │  BEGIN TRANSACTION     │
 │                         │                       ├───────────────────────►│
 │                         │                       │  Create organization   │
 │                         │                       ├───────────────────────►│
 │                         │                       │  Create user           │
 │                         │                       ├───────────────────────►│
 │                         │                       │  COMMIT                │
 │                         │                       ├───────────────────────►│
 │                         │                       │                        │
 │                         │                       │  Generate tokens       │
 │                         │                       │  - Access (15 min)     │
 │                         │                       │  - Refresh (7 days)    │
 │                         │                       │                        │
 │                         │  200 OK               │                        │
 │                         │  { access_token,      │                        │
 │                         │    refresh_token,     │                        │
 │                         │    user, org }        │                        │
 │                         │◄──────────────────────┤                        │
 │  Redirect to dashboard  │                       │                        │
 │◄────────────────────────┤                       │                        │
```

**Security Controls:**
- Email uniqueness enforced at database level (UNIQUE constraint)
- Password requirements: Minimum 8 characters (validated by Zod)
- bcrypt cost factor: 12 (balance security and performance)
- Rate limiting: 10 requests per 15 minutes per IP (authLimiter)

### Login Flow

```
User                    Frontend                Backend                 Database
 │                         │                       │                        │
 │  Submit credentials     │                       │                        │
 ├────────────────────────►│                       │                        │
 │                         │  POST /auth/login     │                        │
 │                         │  { email, password }  │                        │
 │                         ├──────────────────────►│                        │
 │                         │                       │  Validate input        │
 │                         │                       │                        │
 │                         │                       │  Find user by email    │
 │                         │                       ├───────────────────────►│
 │                         │                       │◄───────────────────────┤
 │                         │                       │  User record           │
 │                         │                       │                        │
 │                         │                       │  Verify password       │
 │                         │                       │  (bcrypt.compare)      │
 │                         │                       │                        │
 │                         │                       │  Generate tokens       │
 │                         │                       │  - Access (15 min)     │
 │                         │                       │  - Refresh (7 days)    │
 │                         │                       │                        │
 │                         │                       │  Store refresh token   │
 │                         │                       ├───────────────────────►│
 │                         │                       │                        │
 │                         │  200 OK               │                        │
 │                         │  { access_token,      │                        │
 │                         │    refresh_token,     │                        │
 │                         │    user, org }        │                        │
 │                         │◄──────────────────────┤                        │
 │                         │  Store tokens         │                        │
 │                         │  (localStorage)       │                        │
 │  Redirect to dashboard  │                       │                        │
 │◄────────────────────────┤                       │                        │
```

**Security Controls:**
- Constant-time password comparison (bcrypt prevents timing attacks)
- Account lockout: 5 failed attempts = 15 minute lockout (future enhancement)
- Rate limiting: 10 login attempts per 15 minutes per IP (authLimiter)
- Tokens stored in localStorage (acceptable for MVP, consider httpOnly cookie for production)

### Token Management

**JWT Claims Structure:**

```typescript
interface AccessTokenPayload {
  user_id: string;        // UUID
  organization_id: string; // UUID
  email: string;
  role: 'admin' | 'member'; // For RBAC
  type: 'access';
  iat: number;            // Issued at (Unix timestamp)
  exp: number;            // Expires at (Unix timestamp)
}

interface RefreshTokenPayload {
  user_id: string;
  organization_id: string;
  type: 'refresh';
  iat: number;
  exp: number;
}
```

**Token Lifetimes:**
- Access Token: 15 minutes (short-lived, frequent refresh)
- Refresh Token: 7 days (long-lived, rotated on use)

**Token Refresh Flow:**

```
Frontend                Backend                 Database
    │                       │                        │
    │  POST /auth/refresh   │                        │
    │  { refresh_token }    │                        │
    ├──────────────────────►│                        │
    │                       │  Verify refresh token  │
    │                       │  (JWT signature)       │
    │                       │                        │
    │                       │  Check token exists    │
    │                       ├───────────────────────►│
    │                       │◄───────────────────────┤
    │                       │  Token record found    │
    │                       │                        │
    │                       │  Generate new tokens   │
    │                       │  (both access & refresh)│
    │                       │                        │
    │                       │  Invalidate old refresh│
    │                       ├───────────────────────►│
    │                       │  Store new refresh     │
    │                       ├───────────────────────►│
    │                       │                        │
    │  200 OK               │                        │
    │  { access_token,      │                        │
    │    refresh_token }    │                        │
    │◄──────────────────────┤                        │
```

**Refresh Token Rotation:** Each refresh generates new access + refresh tokens, invalidates old refresh token. Prevents token reuse attacks.

### Authorization Model (RBAC)

**Roles:**
- **Admin:** Full control (invite users, manage projects, configure sources, delete organization)
- **Member:** Read/write projects and sources, cannot invite users or delete organization

**Permission Matrix:**

| Resource | Action | Admin | Member |
|----------|--------|-------|--------|
| Organization | Read | ✓ | ✓ |
| Organization | Update | ✓ | ✗ |
| Organization | Delete | ✓ | ✗ |
| Users | Invite | ✓ | ✗ |
| Users | Remove | ✓ | ✗ |
| Projects | Create | ✓ | ✓ |
| Projects | Read | ✓ | ✓ |
| Projects | Update | ✓ | ✓ |
| Projects | Delete | ✓ | ✓ |
| Sources | Create | ✓ | ✓ |
| Sources | Read | ✓ | ✓ |
| Sources | Update | ✓ | ✓ |
| Sources | Delete | ✓ | ✓ |
| Processing Jobs | Create | ✓ | ✓ |
| Processing Jobs | Read | ✓ | ✓ |

**Implementation:**
- Role stored in users table
- JWT includes role claim
- Middleware checks role for admin-only actions
- ORM filters by organization_id for all queries (row-level security)

### Logout Flow

```
Frontend                Backend                 Database
    │                       │                        │
    │  POST /auth/logout    │                        │
    │  { refresh_token }    │                        │
    ├──────────────────────►│                        │
    │                       │  Verify refresh token  │
    │                       │                        │
    │                       │  Invalidate refresh    │
    │                       ├───────────────────────►│
    │                       │                        │
    │  200 OK               │                        │
    │◄──────────────────────┤                        │
    │  Clear localStorage   │                        │
    │  Redirect to login    │                        │
```

**Security Note:** Access tokens cannot be invalidated (stateless JWT), rely on short expiry (15 min).

### Password Reset Flow

**Phase 1: Request Reset**

```
User                    Frontend                Backend                 Database
 │                         │                       │                        │
 │  Request reset          │                       │                        │
 ├────────────────────────►│                       │                        │
 │                         │  POST /auth/reset     │                        │
 │                         │  { email }            │                        │
 │                         ├──────────────────────►│                        │
 │                         │                       │  Find user by email    │
 │                         │                       ├───────────────────────►│
 │                         │                       │◄───────────────────────┤
 │                         │                       │                        │
 │                         │                       │  Generate reset token  │
 │                         │                       │  (crypto.randomBytes)  │
 │                         │                       │  Expires: 1 hour       │
 │                         │                       │                        │
 │                         │                       │  Store token           │
 │                         │                       ├───────────────────────►│
 │                         │                       │                        │
 │                         │                       │  Send reset email      │
 │                         │                       │  (OPTIONAL)            │
 │                         │                       │                        │
 │                         │  200 OK (always)      │                        │
 │                         │◄──────────────────────┤                        │
 │  Check email message    │                       │                        │
 │◄────────────────────────┤                       │                        │
```

**Phase 2: Complete Reset**

```
User                    Frontend                Backend                 Database
 │                         │                       │                        │
 │  Click email link       │                       │                        │
 │  (with token)           │                       │                        │
 ├────────────────────────►│                       │                        │
 │                         │  GET /auth/reset/:token│                       │
 │                         ├──────────────────────►│                        │
 │                         │                       │  Verify token exists   │
 │                         │                       │  and not expired       │
 │                         │                       ├───────────────────────►│
 │                         │                       │◄───────────────────────┤
 │                         │  Show reset form      │                        │
 │                         │◄──────────────────────┤                        │
 │                         │                       │                        │
 │  Submit new password    │                       │                        │
 ├────────────────────────►│                       │                        │
 │                         │  POST /auth/reset/:token│                      │
 │                         │  { password }         │                        │
 │                         ├──────────────────────►│                        │
 │                         │                       │  Verify token          │
 │                         │                       │                        │
 │                         │                       │  Hash new password     │
 │                         │                       │  (bcrypt cost 12)      │
 │                         │                       │                        │
 │                         │                       │  Update user password  │
 │                         │                       ├───────────────────────►│
 │                         │                       │  Invalidate token      │
 │                         │                       ├───────────────────────►│
 │                         │                       │  Invalidate all refresh│
 │                         │                       │  tokens (force re-login)│
 │                         │                       ├───────────────────────►│
 │                         │                       │                        │
 │                         │  200 OK               │                        │
 │                         │◄──────────────────────┤                        │
 │  Redirect to login      │                       │                        │
 │◄────────────────────────┤                       │                        │
```

**Security Controls:**
- Reset token: Cryptographically random, 32 bytes, URL-safe
- Token expiry: 1 hour
- Single-use token: Invalidated after successful reset
- Force logout: All refresh tokens invalidated on password change
- Rate limiting: 3 reset requests per hour per email
- Email confirmation: Always return 200 (don't leak email existence)

---

## 6. Security Architecture (MVP)

### Security Middleware Configuration

**Helmet Configuration:**

```typescript
// server/middleware/security.ts
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: false,  // Relaxed for MVP (Vite injects inline scripts)
  crossOriginEmbedderPolicy: false, // Relaxed for third-party resources
  hsts: {
    maxAge: 31536000, // 1 year
    includeSubDomains: true,
    preload: true
  },
  frameguard: { action: 'deny' }, // Prevent clickjacking
  noSniff: true, // Prevent MIME sniffing
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' }
}));
```

**CORS Configuration:**

```typescript
// server/middleware/security.ts
import cors from 'cors';

const corsOptions = {
  origin: process.env.NODE_ENV === 'production' 
    ? process.env.APP_URL  // Only allow production domain
    : true,                 // Allow all origins in development
  credentials: true,        // Allow cookies/auth headers
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  exposedHeaders: ['X-RateLimit-Limit', 'X-RateLimit-Remaining', 'X-RateLimit-Reset'],
  maxAge: 86400             // Cache preflight for 24 hours
};

app.use(cors(corsOptions));
```

**Rate Limiting:**

```typescript
// server/middleware/rate-limit.ts
import rateLimit from 'express-rate-limit';

// Global rate limiter: 100 requests per 15 minutes
export const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  standardHeaders: true,  // Return rate limit info in headers
  legacyHeaders: true,
  message: {
    error: {
      code: 'RATE_LIMITED',
      message: 'Too many requests, please try again later'
    }
  },
  handler: (req, res) => {
    res.status(429).json({
      error: {
        code: 'RATE_LIMITED',
        message: 'Too many requests, please try again later'
      }
    });
  }
});

// Auth rate limiter: 10 requests per 15 minutes
export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 10,
  standardHeaders: true,
  legacyHeaders: true,
  message: {
    error: {
      code: 'RATE_LIMITED',
      message: 'Too many authentication attempts, please try again later'
    }
  }
});

// Upload rate limiter: 20 uploads per hour
export const uploadLimiter = rateLimit({
  windowMs: 60 * 60 * 1000,
  max: 20,
  standardHeaders: true,
  legacyHeaders: true,
  message: {
    error: {
      code: 'RATE_LIMITED',
      message: 'Upload limit exceeded, please try again later'
    }
  }
});
```

**Rate Limit Headers (MANDATORY on ALL responses):**
- `X-RateLimit-Limit`: Max requests in window
- `X-RateLimit-Remaining`: Remaining requests
- `X-RateLimit-Reset`: Unix timestamp when window resets

### Input Validation

**Validation Strategy:**
- All user inputs validated with Zod schemas
- Validation occurs at route level before controller logic
- URL parameters validated with parseIntParam utility
- File uploads validated for type, size, content

**Example Validation Schemas:**

```typescript
// server/validators/auth.ts
import { z } from 'zod';

export const registerSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain uppercase letter')
    .regex(/[a-z]/, 'Password must contain lowercase letter')
    .regex(/[0-9]/, 'Password must contain number'),
  name: z.string().min(1, 'Name required').max(100),
  organization_name: z.string().min(1, 'Organization name required').max(100)
});

export const loginSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(1, 'Password required')
});
```

**URL Parameter Validation:**

```typescript
// server/lib/validation.ts
import { BadRequestError } from '../errors';

export function parseIntParam(value: string, paramName: string): number {
  const parsed = parseInt(value, 10);
  if (!Number.isFinite(parsed) || parsed < 1) {
    throw new BadRequestError(`Invalid ${paramName}`);
  }
  return parsed;
}

// Usage in routes:
app.get('/projects/:id', (req, res) => {
  const projectId = parseIntParam(req.params.id, 'project ID');
  // ... rest of handler
});
```

**File Upload Validation:**

```typescript
// server/validators/upload.ts
import { z } from 'zod';

const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB
const ALLOWED_TYPES = ['text/csv', 'application/json', 'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'];

export function validateFileUpload(file: Express.Multer.File) {
  if (!file) {
    throw new BadRequestError('No file provided');
  }
  
  if (file.size > MAX_FILE_SIZE) {
    throw new BadRequestError(`File too large (max ${MAX_FILE_SIZE / 1024 / 1024}MB)`);
  }
  
  if (!ALLOWED_TYPES.includes(file.mimetype)) {
    throw new BadRequestError('Invalid file type (CSV, JSON, or Excel only)');
  }
}
```

### Error Handling

**Error Class Hierarchy:**

```typescript
// server/errors.ts
export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number,
    public code: string,
  ) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}

export class BadRequestError extends AppError {
  constructor(message: string) {
    super(message, 400, 'BAD_REQUEST');
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string = 'Unauthorized') {
    super(message, 401, 'UNAUTHORIZED');
  }
}

export class ForbiddenError extends AppError {
  constructor(message: string = 'Forbidden') {
    super(message, 403, 'FORBIDDEN');
  }
}

export class NotFoundError extends AppError {
  constructor(message: string) {
    super(message, 404, 'NOT_FOUND');
  }
}

export class ConflictError extends AppError {
  constructor(message: string) {
    super(message, 409, 'CONFLICT');
  }
}

export class InternalServerError extends AppError {
  constructor(message: string = 'Internal server error') {
    super(message, 500, 'INTERNAL_SERVER_ERROR');
  }
}
```

**Error Middleware:**

```typescript
// server/middleware/error-handler.ts
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../errors';

export function errorHandler(
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction,
) {
  // Handle known application errors
  if (err instanceof AppError) {
    return res.status(err.statusCode).json({
      error: {
        code: err.code,
        message: err.message,
      },
    });
  }

  // Handle Zod validation errors
  if (err.name === 'ZodError') {
    return res.status(400).json({
      error: {
        code: 'VALIDATION_ERROR',
        message: 'Invalid input',
        details: err.errors,
      },
    });
  }

  // Handle unexpected errors
  console.error('Unhandled error:', err);
  
  res.status(500).json({
    error: {
      code: 'INTERNAL_SERVER_ERROR',
      message: process.env.NODE_ENV === 'production' 
        ? 'An unexpected error occurred'
        : err.message,
    },
  });
}
```

### Password Security

**Hashing Configuration:**
- Algorithm: bcrypt
- Cost factor: 12 (2^12 = 4096 rounds)
- Rationale: Balance security and performance; ~250ms per hash on modern hardware

```typescript
// server/lib/password.ts
import bcrypt from 'bcryptjs';

const BCRYPT_ROUNDS = 12;

export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, BCRYPT_ROUNDS);
}

export async function verifyPassword(
  password: string,
  hash: string
): Promise<boolean> {
  return bcrypt.compare(password, hash);
}
```

### JWT Security

**Configuration:**

```typescript
// server/lib/jwt.ts
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET!;
const ACCESS_TOKEN_EXPIRY = '15m';
const REFRESH_TOKEN_EXPIRY = '7d';

export function signAccessToken(payload: AccessTokenPayload): string {
  return jwt.sign(
    { ...payload, type: 'access' },
    JWT_SECRET,
    { expiresIn: ACCESS_TOKEN_EXPIRY }
  );
}

export function signRefreshToken(payload: RefreshTokenPayload): string {
  return jwt.sign(
    { ...payload, type: 'refresh' },
    JWT_SECRET,
    { expiresIn: REFRESH_TOKEN_EXPIRY }
  );
}

export function verifyAccessToken(token: string): AccessTokenPayload {
  const payload = jwt.verify(token, JWT_SECRET) as AccessTokenPayload;
  if (payload.type !== 'access') {
    throw new UnauthorizedError('Invalid token type');
  }
  return payload;
}

export function verifyRefreshToken(token: string): RefreshTokenPayload {
  const payload = jwt.verify(token, JWT_SECRET) as RefreshTokenPayload;
  if (payload.type !== 'refresh') {
    throw new UnauthorizedError('Invalid token type');
  }
  return payload;
}
```

**Security Controls:**
- Secret: 256-bit random key (32 bytes hex) stored in ENCRYPTION_KEY env var
- Algorithm: HS256 (HMAC-SHA256)
- Token type claim prevents access/refresh token confusion
- Short expiry for access tokens (15 min)
- Refresh token rotation on use

### Request Logging

```typescript
// server/middleware/logging.ts
import morgan from 'morgan';

export function setupLogging(app: Express) {
  const format = process.env.NODE_ENV === 'production' 
    ? 'combined'  // Apache combined log format
    : 'dev';      // Colorized dev format
  
  app.use(morgan(format));
}
```

**Log Format (production):**
```
:remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"
```

### Security Checklist (MVP)

- [x] Helmet middleware configured
- [x] CORS origin-restricted in production
- [x] Rate limiting (global + auth-specific)
- [x] Password hashing (bcrypt cost 12)
- [x] Input validation (Zod schemas)
- [x] JWT token expiration (15 min access, 7 day refresh)
- [x] Refresh token rotation
- [x] Error handling (no stack traces in production)
- [x] Request logging (morgan)
- [x] HTTPS enforced (Replit provides)
- [x] SQL injection prevention (parameterized queries via Drizzle)
- [x] XSS prevention (React escapes by default)
- [x] CSRF not needed (stateless JWT)

---

## 7. Data Architecture Overview

### Data Flow

```
┌─────────────┐
│ User Upload │
│  CSV/JSON/  │
│   Excel     │
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────┐
│    File Parser                  │
│  - Detect format                │
│  - Extract schema               │
│  - Parse rows                   │
│  - Handle errors                │
└──────┬──────────────────────────┘
       │ Raw Records
       ▼
┌─────────────────────────────────┐
│    PII Detector                 │
│  - Regex pattern matching       │
│  - Field name heuristics        │
│  - Generate suggestions         │
└──────┬──────────────────────────┘
       │ PII Annotations
       ▼
┌─────────────────────────────────┐
│    Schema Mapper                │
│  - Apply field mappings         │
│  - Transform types              │
│  - Validate schema              │
└──────┬──────────────────────────┘
       │ Mapped Records
       ▼
┌─────────────────────────────────┐
│    De-identification Engine     │
│  - Apply rules (mask/hash/etc)  │
│  - Maintain consistency         │
│  - Track lineage                │
└──────┬──────────────────────────┘
       │ Clean Records
       ▼
┌─────────────────────────────────┐
│    Dataset Generator            │
│  - Generate CSV                 │
│  - Create download link         │
│  - Store metadata               │
└──────┬──────────────────────────┘
       │
       ▼
┌─────────────┐
│  Download   │
│   CSV File  │
└─────────────┘
```

### Storage Strategy

**Primary Storage: PostgreSQL**
- Multi-tenant data model with organization_id on all tables
- File content stored in BYTEA columns (Replit ephemeral filesystem constraint)
- Processed datasets stored temporarily (7-day retention)
- JSONB for flexible source configurations and processing metadata

**Caching Strategy (MVP):**
- No explicit caching layer (keep it simple)
- Database connection pooling (10 connections)
- React Query provides client-side caching (5 min stale time)
- Future: Consider Redis for session storage, processing job queues

**File Storage Rationale:**

**Why PostgreSQL BYTEA?**
- Replit has ephemeral filesystem (files don't persist across restarts)
- Database provides transactional consistency (file + metadata atomicity)
- Simpler architecture (no object storage integration)
- Sufficient for MVP scale (100MB max, 50 users)

**Limitations:**
- Database bloat (100MB files stored directly)
- Backup size increases
- Slower queries if files are frequently accessed alongside metadata

**Migration Path:** If database storage becomes problematic post-MVP, refactor to Cloudflare R2 or S3-compatible storage with signed URLs.

### Data Retention

| Data Type | Retention Period | Rationale |
|-----------|------------------|-----------|
| Raw uploaded files | 30 days | Support re-processing, troubleshooting |
| Processed datasets | 7 days | Temporary download links, then delete |
| Processing metadata | Permanent | Audit trail, lineage tracking |
| Audit logs | 1 year | Compliance, investigation |
| User accounts | Until deleted | User controls |

---

## 8. Third-Party Integrations

### Email Service (OPTIONAL)

**Service: Resend**

**Classification:** OPTIONAL (system works without email, logs to console in development)

**Purpose:** Send invitation emails, password reset emails

**API Type:** REST API (HTTPS + JSON)

**Authentication:** API key in Authorization header
```
Authorization: Bearer re_xxxxxxxxxxxx
```

**Endpoints Used:**
- POST /emails - Send email

**Rate Limits:** 
- Free tier: 100 emails/day
- Paid tier: 50,000+ emails/month

**Cost:** 
- Free: $0 (100 emails/day)
- Starter: $20/month (50,000 emails)

**Failure Modes:**
- **API down:** Log email to console, continue without sending
- **Rate limit exceeded:** Log error, queue for retry (future enhancement)
- **Invalid API key:** Log error, continue without sending

**Fallback Strategy:** 
- Development: Log emails to console, display in UI
- Production: Log failure, notify admin, manual follow-up if critical

**Configuration:**
```typescript
// server/config.ts
export const emailConfig = {
  provider: 'resend',
  apiKey: process.env.RESEND_API_KEY, // OPTIONAL
  fromEmail: process.env.FROM_EMAIL || 'noreply@foundry.example.com',
  enabled: !!process.env.RESEND_API_KEY,
};
```

**Alternative Providers:**
- SendGrid (more mature, similar pricing)
- Postmark (excellent deliverability, transactional focus)
- AWS SES (complex setup, high volume discount)

### Teamwork Desk Integration (REQUIRED)

**Service: Teamwork Desk REST API v3**

**Classification:** REQUIRED (core feature per PRD)

**Purpose:** Fetch support tickets for processing

**API Type:** REST API (HTTPS + JSON)

**Authentication:** OAuth 2.0 (Authorization Code Flow)

**OAuth Flow:**
1. User clicks "Connect Teamwork Desk" in UI
2. Frontend redirects to Teamwork OAuth endpoint with client_id, redirect_uri, scope
3. User authorizes in Teamwork UI
4. Teamwork redirects back with authorization code
5. Backend exchanges code for access_token + refresh_token
6. Store tokens encrypted in api_credentials table
7. Use access_token for API requests
8. Refresh when access_token expires (typically 1 hour)

**Endpoints Used:**
- GET /api/v3/tickets.json - List tickets
- GET /api/v3/tickets/{id}.json - Get ticket details
- GET /api/v3/customers.json - List customers (for metadata)

**Request Format:**
```
GET https://{installation}.teamwork.com/api/v3/tickets.json
Authorization: Bearer {access_token}
```

**Response Pagination:**
- Cursor-based or page-based (verify in Teamwork API docs)
- Max 100 results per page
- Follow next_page links until exhausted

**Rate Limits:**
- Not explicitly documented; assume 100 requests/minute
- Implement exponential backoff if 429 responses

**Cost:**
- No API charges (included with Teamwork Desk subscription)
- User must have valid Teamwork Desk account

**Failure Modes:**
- **OAuth failure:** Show error in UI, prompt re-authentication
- **Invalid token:** Refresh access token, retry
- **API down:** Show error, offer manual CSV upload fallback
- **Rate limited:** Queue requests, implement backoff
- **Missing permissions:** Show error, guide user to grant scopes

**Data Extraction:**
- Fetch tickets in batches of 100
- Extract: ticket ID, subject, status, priority, customer, created_at, updated_at, messages
- Store in sources table as JSONB for processing pipeline

**Security:**
- OAuth tokens encrypted at rest (AES-256-GCM)
- Tokens stored per-organization (multi-tenant isolation)
- Refresh tokens rotated on use

**Configuration:**
```typescript
// server/config.ts
export const teamworkConfig = {
  clientId: process.env.TEAMWORK_CLIENT_ID,      // REQUIRED
  clientSecret: process.env.TEAMWORK_CLIENT_SECRET, // REQUIRED
  redirectUri: process.env.TEAMWORK_REDIRECT_URI,   // REQUIRED
  scopes: ['read:tickets', 'read:customers'],
};
```

---

## 9. Replit Deployment Configuration

### .replit File

```toml
[deployment]
run = ["sh", "-c", "npm run build && npm start"]
deploymentTarget = "cloudrun"

[[ports]]
localPort = 5000
externalPort = 80
```

### Environment Variables

**REQUIRED (application fails to start if missing):**

| Variable | Purpose | Example | Validation |
|----------|---------|---------|------------|
| DATABASE_URL | PostgreSQL connection string | postgresql://user:pass@host:5432/db | Checked at startup |
| JWT_SECRET | JWT signing key | 64-char hex string | Checked at startup |
| ENCRYPTION_KEY | AES-256 encryption key | 64-char hex string (32 bytes) | Checked at startup |
| NODE_ENV | Environment (production/development) | production | Defaults to development |
| APP_URL | Production app URL (for CORS) | https://foundry.repl.co | Required in production |
| TEAMWORK_CLIENT_ID | Teamwork OAuth client ID | tw_xxxxxxxxxxxx | Required for integration |
| TEAMWORK_CLIENT_SECRET | Teamwork OAuth secret | secret_xxxxxxxxxxxx | Required for integration |
| TEAMWORK_REDIRECT_URI | OAuth callback URL | https://foundry.repl.co/auth/teamwork/callback | Required for integration |

**OPTIONAL (graceful degradation if missing):**

| Variable | Purpose | Example | Fallback Behavior |
|----------|---------|---------|-------------------|
| RESEND_API_KEY | Resend email API key | re_xxxxxxxxxxxx | Log emails to console |
| FROM_EMAIL | Email from address | noreply@foundry.example.com | Use default |
| LOG_LEVEL | Logging verbosity | debug | Defaults to 'info' |

### Port Configuration

```typescript
// server/index.ts
const PORT = process.env.PORT || 5000; // Replit sets PORT=5000

const server = app.listen(PORT, () => {
  console.log(`Server listening on port ${PORT}`);
  console.log(`Environment: ${process.env.NODE_ENV}`);
});
```

**CRITICAL:** Replit exposes port 5000 publicly. Do not hardcode other ports.

### Startup Validation

```typescript
// server/config.ts
const requiredEnvVars = [
  'DATABASE_URL',
  'JWT_SECRET',
  'ENCRYPTION_KEY',
  'TEAMWORK_CLIENT_ID',
  'TEAMWORK_CLIENT_SECRET',
  'TEAMWORK_REDIRECT_URI',
];

export function validateEnvironment() {
  const missing = requiredEnvVars.filter(key => !process.env[key]);
  
  if (missing.length > 0) {
    throw new Error(
      `Missing required environment variables: ${missing.join(', ')}\n` +
      'Set these in Replit Secrets before starting the application.'
    );
  }
  
  // Validate JWT_SECRET length (minimum 32 characters)
  if (process.env.JWT_SECRET!.length < 32) {
    throw new Error('JWT_SECRET must be at least 32 characters');
  }
  
  // Validate ENCRYPTION_KEY format (64 hex chars = 32 bytes)
  if (!/^[0-9a-f]{64}$/i.test(process.env.ENCRYPTION_KEY!)) {
    throw new Error('ENCRYPTION_KEY must be 64 hexadecimal characters (32 bytes)');
  }
  
  // Warn about optional variables
  if (!process.env.RESEND_API_KEY) {
    console.warn('RESEND_API_KEY not set - emails will be logged to console');
  }
}
```

### Build Configuration

**package.json scripts:**

```json
{
  "scripts": {
    "dev": "concurrently \"npm run dev:server\" \"npm run dev:client\"",
    "dev:server": "tsx watch server/index.ts",
    "dev:client": "vite",
    "build": "npm run build:client && npm run build:server",
    "build:client": "vite build",
    "build:server": "tsc --project tsconfig.server.json",
    "start": "NODE_ENV=production node dist/server/index.js",
    "migrate": "tsx server/db/migrate.ts",
    "db:push": "drizzle-kit push"
  }
}
```

**vite.config.ts:**

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
    },
    watch: {
      ignored: [
        '**/node_modules/**',
        '**/.git/**',
        '**/dist/**',
        '**/.replit/**',
        '**/replit.nix/**',
      ],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  build: {
    outDir: 'dist/client',
    sourcemap: false,
  },
});
```

### Graceful Shutdown

```typescript
// server/index.ts
import { db } from './db';

process.on('SIGTERM', async () => {
  console.log('SIGTERM received, closing server gracefully...');
  
  // Stop accepting new connections
  server.close(() => {
    console.log('HTTP server closed');
  });
  
  // Close database connections
  await db.end();
  console.log('Database connections closed');
  
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('SIGINT received, closing server gracefully...');
  
  server.close(() => {
    console.log('HTTP server closed');
  });
  
  await db.end();
  console.log('Database connections closed');
  
  process.exit(0);
});
```

### Cold Start Optimization

**Issue:** Replit puts applications to sleep after inactivity. First request after sleep has high latency.

**Mitigation:**
- Keep database connections pooled (connection reused on wake)
- Lazy-load heavy dependencies
- Health endpoint responds quickly
- Consider periodic keep-alive pings (external service pings /health every 5 min)

---

## 10. Architecture Decision Records

### ADR-001: Use Monolithic Architecture

**Context:**
Foundry is an MVP for 50-100 organizations. Replit deployment constraint requires single container. Team is single full-stack developer.

**Decision:**
Build as monolithic application with clear module boundaries, not microservices.

**Alternatives Considered:**
1. **Microservices:** Separate services for API, processing, integrations
   - Rejected: Replit single-container constraint, overkill for MVP scale
2. **Serverless:** AWS Lambda for processing pipeline
   - Rejected: Replit deployment requirement, cold start issues, complexity

**Consequences:**

**Positive:**
- Simplified deployment (one process)
- Faster development (no distributed system debugging)
- Easier data consistency (single database)
- Lower operational complexity
- Clear upgrade path (extract modules to services later)

**Negative:**
- Entire application scales together (cannot scale processing independently)
- Harder to isolate failures (one module crash takes down app)
- Mixed concerns in single codebase (requires discipline)

**Mitigation:**
- Strict module boundaries with clear interfaces
- Document extraction plan for processing engine (future microservice)
- Use async processing to prevent blocking API requests

---

### ADR-002: Store Files in PostgreSQL BYTEA

**Context:**
Replit has ephemeral filesystem. Files uploaded between restarts are lost. Need persistent file storage.

**Decision:**
Store uploaded files in PostgreSQL BYTEA columns, not filesystem or object storage.

**Alternatives Considered:**
1. **Filesystem:** Store files in /home/claude
   - Rejected: Ephemeral filesystem on Replit, files lost on restart
2. **Cloudflare R2:** Object storage with S3-compatible API
   - Rejected: Adds external dependency, cost, complexity for MVP
3. **Base64 in JSON field:** Store as text
   - Rejected: 33% size overhead, inefficient

**Consequences:**

**Positive:**
- Transactional consistency (file + metadata in same transaction)
- Simplified architecture (no object storage integration)
- No additional cost or external dependencies
- Works with Replit constraints

**Negative:**
- Database bloat (100MB files in BYTEA columns)
- Larger backup size
- Slower queries if files accessed with metadata
- Performance degradation at scale

**Mitigation:**
- Set hard file size limit (100MB max)
- Separate file storage from metadata queries (fetch file only when needed)
- Document migration path to R2/S3 if database storage becomes problematic

**Migration Path:**
If database file storage hits limits post-MVP:
1. Set up Cloudflare R2 account
2. Add R2_BUCKET_URL environment variable
3. Refactor file upload to store in R2, save URL in database
4. Migrate existing files from BYTEA to R2 (one-time script)
5. Update download logic to generate signed URLs

---

### ADR-003: Use In-Process Task Queue for Background Processing

**Context:**
Processing pipeline (parse → detect PII → map → de-identify → generate) takes 2-3 minutes for 1000 records. Cannot block HTTP request. Need background processing.

**Decision:**
Implement simple in-process task queue with job state tracking, not external queue service.

**Alternatives Considered:**
1. **BullMQ + Redis:** Robust job queue with persistence
   - Rejected: Requires Redis (external dependency), overkill for MVP scale (5-10 concurrent jobs)
2. **pg-boss:** PostgreSQL-based job queue
   - Rejected: Adds complexity, MVP doesn't need advanced features (retries, cron, etc.)
3. **Synchronous processing:** Block HTTP request until complete
   - Rejected: Timeouts for large files, poor UX

**Consequences:**

**Positive:**
- Zero external dependencies (no Redis, no worker infrastructure)
- Simple implementation (in-memory queue, database for state)
- Sufficient for MVP scale (5-10 concurrent jobs)
- Fast job dispatch (no network latency)
- Easy debugging (single process)

**Negative:**
- Jobs lost on process restart (no persistence beyond database state)
- Cannot scale processing horizontally (tied to single process)
- Limited concurrency (5-10 jobs max before memory pressure)
- No advanced features (retries, scheduled jobs, priority)

**Mitigation:**
- Store job state in processing_jobs table (resume on restart)
- Limit concurrent jobs to 5 (prevent memory exhaustion)
- Document upgrade path to BullMQ if scale demands

**Implementation:**

```typescript
// server/lib/task-queue.ts
interface Task {
  id: string;
  type: 'process_source';
  payload: any;
  status: 'pending' | 'running' | 'completed' | 'failed';
}

class TaskQueue {
  private queue: Task[] = [];
  private running: Map<string, Promise<void>> = new Map();
  private maxConcurrent = 5;

  async enqueue(task: Task): Promise<void> {
    this.queue.push(task);
    await this.processQueue();
  }

  private async processQueue(): Promise<void> {
    while (this.queue.length > 0 && this.running.size < this.maxConcurrent) {
      const task = this.queue.shift()!;
      const promise = this.executeTask(task);
      this.running.set(task.id, promise);
      
      promise.finally(() => {
        this.running.delete(task.id);
        this.processQueue(); // Process next task
      });
    }
  }

  private async executeTask(task: Task): Promise<void> {
    // Update job status to 'running'
    // Execute processing pipeline
    // Update job status to 'completed' or 'failed'
  }
}
```

**Migration Path:**
If in-process queue insufficient post-MVP:
1. Install BullMQ + Redis
2. Replace TaskQueue with BullMQ
3. Add dedicated worker processes (scale independently)
4. Add retry logic, job priorities, scheduled jobs

---

### ADR-004: Use Polling for Real-Time Progress Tracking

**Context:**
Users need real-time feedback during 2-3 minute processing jobs. Need to show progress (parsing, detecting PII, mapping, de-identifying, generating).

**Decision:**
Use polling-based progress tracking (frontend polls GET /processing-jobs/:id every 2 seconds), not WebSockets or Server-Sent Events.

**Alternatives Considered:**
1. **WebSockets:** Bi-directional persistent connection
   - Rejected: Adds deployment complexity (connection state management), unnecessary for one-way updates, Replit support unclear
2. **Server-Sent Events (SSE):** Server pushes updates to client
   - Rejected: HTTP/1.1 connection limit (6 per domain), Replit reverse proxy behavior unknown
3. **Long polling:** Client holds request open until update
   - Rejected: More complex than short polling, marginal efficiency gain

**Consequences:**

**Positive:**
- Simple implementation (standard REST endpoints)
- No persistent connections (stateless, scales horizontally)
- Works reliably on Replit (no reverse proxy complications)
- Familiar pattern (easy debugging)
- Graceful degradation (if polling fails, user can refresh)

**Negative:**
- Network inefficiency (HTTP overhead every 2 seconds)
- Delayed updates (up to 2 second lag)
- Increased database load (frequent status checks)

**Mitigation:**
- Cache job status in memory (reduce database queries)
- Stop polling when job complete (frontend unsubscribes)
- Increase interval to 5 seconds for long jobs (configurable)

**Implementation:**

```typescript
// Frontend: useProcessingJob hook
function useProcessingJob(jobId: string) {
  const { data, error } = useQuery({
    queryKey: ['processing-job', jobId],
    queryFn: () => fetch(`/api/processing-jobs/${jobId}`).then(r => r.json()),
    refetchInterval: (data) => {
      // Stop polling when complete or failed
      if (data?.status === 'completed' || data?.status === 'failed') {
        return false;
      }
      return 2000; // Poll every 2 seconds
    },
  });
  
  return { job: data, error };
}
```

**Migration Path:**
If polling insufficient (many concurrent users, high database load):
1. Add Redis for job status caching
2. Evaluate WebSockets/SSE if Replit supports
3. Batch status updates (send multiple job statuses in single response)

---

### ADR-005: Use Drizzle ORM with postgres-js Driver

**Context:**
Need type-safe database access with minimal abstraction. Constitution mandates postgres-js driver. Team prefers SQL-like syntax over query builders.

**Decision:**
Use Drizzle ORM (Core Select API) with postgres-js driver.

**Alternatives Considered:**
1. **Prisma:** Popular ORM with excellent TypeScript support
   - Rejected: Constitution mandates postgres-js, Prisma uses its own client
2. **Kysely:** Type-safe SQL query builder
   - Rejected: Query builder not full ORM (no schema definition, migrations)
3. **TypeORM:** Mature ORM with decorators
   - Rejected: Decorator-heavy (magic), Constitution requires postgres-js
4. **Raw SQL with postgres-js:** No abstraction
   - Rejected: Loses type safety, manual migration management

**Consequences:**

**Positive:**
- Type-safe queries (full TypeScript inference)
- Minimal abstraction (SQL-like syntax)
- Excellent performance (postgres-js is fastest driver)
- Constitution compliance (postgres-js mandate)
- Schema-first migrations (explicit schema definitions)

**Negative:**
- Smaller ecosystem than Prisma (fewer examples)
- Less mature (newer ORM, evolving API)
- Core Select API only (no Relational Query API)

**Mitigation:**
- Document schema and common queries
- Use Core Select API explicitly (avoid experimental features)
- Monitor Drizzle updates for breaking changes

**Example Usage:**

```typescript
// server/db/schema.ts
import { pgTable, uuid, text, timestamp } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  email: text('email').notNull().unique(),
  password_hash: text('password_hash').notNull(),
  name: text('name').notNull(),
  organization_id: uuid('organization_id').notNull(),
  created_at: timestamp('created_at').defaultNow().notNull(),
});

// server/repositories/users.ts
import { db } from '../db';
import { users } from '../db/schema';
import { eq } from 'drizzle-orm';

export async function findUserByEmail(email: string) {
  const result = await db.select().from(users).where(eq(users.email, email)).limit(1);
  return result[0] || null;
}
```

---

## 11. Validation Footer

### Completeness Checklist

- [x] All PRD features have architectural support (see section 3)
- [x] Technology stack complete with rationale (see section 2)
- [x] Auth flows fully specified (see section 5)
- [x] Integrations classified (required/optional) (see section 8)
- [x] Replit configuration complete (see section 9)
- [x] Security middleware specified (see section 6)
- [x] Minimum 5 ADRs documented (see section 10)

### Prompt Maintenance Contract

If this prompt is edited, you MUST:
1. Update version history with changes and `Hygiene Gate: PASS`
2. Re-run Prompt Hygiene Gate checks (Constitution Section L)
3. Confirm clean encoding (no mojibake/non-ASCII artifacts)
4. Verify no global rule restatements (reference Constitution instead)

Failed checks invalidate prompt update.

### Prompt Hygiene Gate (Constitution Section L)

- [x] Framework Version header present and correct
- [x] Encoding scan: No non-ASCII artifact tokens
- [x] Inheritance references Constitution v3.1
- [x] No full global rule restatements (uses "Per Constitution Section X")

### Confidence Scores

| Section | Score (1-10) | Notes |
|---------|--------------|-------|
| Architectural Overview | 9 | Clear pattern choice, validated against Replit constraints |
| Technology Stack | 9 | Well-justified, considered alternatives, Replit-compatible |
| PRD Traceability | 10 | Every PRD feature mapped to architecture |
| Component Architecture | 8 | Clear responsibilities, some detail requires implementation validation |
| Auth & Authorization | 9 | Complete flows, security controls specified |
| Security Architecture | 9 | MVP-appropriate, all mandatory controls present |
| Data Architecture | 8 | File storage decision has trade-offs, migration path clear |
| Third-Party Integrations | 9 | REQUIRED/OPTIONAL classified, failure modes documented |
| Replit Configuration | 10 | Complete environment variables, port config, startup validation |
| ADRs | 9 | 5 critical decisions documented with alternatives and consequences |

### Document Status: COMPLETE

All sections delivered. Architecture ready for downstream agents.

---

## 12. Downstream Agent Handoff Brief

### Global Platform Context (All Agents)

Per Constitution Section C: Standard response/error envelopes, auth storage, API conventions apply.
Per Constitution Section D: Replit platform non-negotiables (postgres-js driver, ports, deployment model).

### Agent 3: Data Modeling

**Database:**
- PostgreSQL 15 via Replit managed DB
- postgres-js driver (Constitution Section D)
- Connection pooling: max 10 connections, 20s idle timeout

**ORM:**
- Drizzle ORM (Core Select API only)
- Schema-first migrations
- Type-safe queries

**Key Entities Implied by Architecture:**
- users (authentication, multi-tenant isolation)
- organizations (multi-tenant root)
- projects (user-created workspaces)
- sources (uploaded files, API connections)
- processing_jobs (background job state tracking)
- field_mappings (schema transformation rules)
- deidentification_rules (PII handling rules)
- invitations (user invite tokens)
- api_credentials (encrypted OAuth tokens for Teamwork)
- audit_logs (compliance, lineage tracking)
- refresh_tokens (JWT refresh token rotation)

**File Storage:**
- BYTEA columns for uploaded files (Replit ephemeral filesystem constraint)
- Max file size: 100MB
- Files fetched separately from metadata queries

**Multi-Tenancy:**
- organization_id on all domain tables
- Row-level filtering via ORM (no database-level RLS for MVP)
- JWT includes organization_id claim

### Agent 4: API Contract

**Framework:**
- Express.js 4
- TypeScript 5

**Response/Error Envelopes:**
- Per Constitution Section C

**Authentication:**
- JWT Bearer tokens (Constitution Section C)
- Access token: 15 minutes expiry
- Refresh token: 7 days expiry
- Token rotation on refresh

**Middleware Stack (in order):**
1. morgan (request logging)
2. helmet (security headers)
3. cors (origin validation)
4. express-rate-limit (global + auth-specific)
5. express.json() (body parsing)
6. Auth middleware (JWT verification, org context)
7. Route handlers
8. Error handler (must be last)

**Key Routes Required:**
- POST /auth/register
- POST /auth/login
- POST /auth/refresh
- POST /auth/logout
- POST /auth/reset (password reset request)
- POST /auth/reset/:token (complete reset)
- GET /projects (list)
- POST /projects (create)
- GET /projects/:id
- PUT /projects/:id
- DELETE /projects/:id
- POST /sources (file upload)
- GET /sources/:id
- POST /sources/:id/process (trigger processing)
- GET /processing-jobs/:id (status polling)
- GET /processing-jobs/:id/download
- GET /auth/teamwork/authorize (OAuth start)
- GET /auth/teamwork/callback (OAuth callback)

**Input Validation:**
- Zod schemas for all inputs
- parseIntParam for URL parameters
- File upload validation (type, size)

**Rate Limiting:**
- Global: 100 req / 15 min
- Auth: 10 req / 15 min
- Upload: 20 req / 60 min

### Agent 5: UI/UX Specification

**Framework:**
- React 18 + Vite
- TypeScript 5

**Component Library:**
- shadcn/ui (copy-paste components)
- Radix UI primitives (accessibility)

**Styling:**
- Tailwind CSS 3 with CSS variables
- Dark mode support (future enhancement)

**State Management:**
- React Query for server state (5 min stale time)
- useState/useContext for UI state

**Routing:**
- React Router 6

**Key Pages Required:**
- /login
- /register
- /reset-password
- /reset-password/:token
- /dashboard (project list)
- /projects/:id (project detail, source list)
- /projects/:id/sources/new (upload + configure)
- /processing/:jobId (processing progress)

**Key Components:**
- File upload with drag-and-drop
- Field mapping interface (drag source → target)
- Progress indicator (5 stages: parsing, detecting, mapping, de-identifying, generating)
- Data preview table (sampled records)
- Download button (generate temporary link)

**Critical UX:**
- Show file upload progress (chunked upload)
- Poll processing status every 2 seconds
- Show processing stage + progress percentage
- Auto-download when processing completes
- Error recovery (re-run processing, upload different file)

### Agent 6: Implementation Orchestrator

**Security Middleware Required:**
- helmet (security headers)
- cors (cross-origin requests)
- express-rate-limit (global + auth + upload limiters)
- morgan (request logging)

**Critical Configurations:**
- Port 5000 (Replit)
- Trust proxy: true (for rate limiting behind Replit reverse proxy)
- Vite watch ignored: .replit, replit.nix directories
- CORS origin: APP_URL in production, true in development

**File Upload Configuration:**
- Multipart/form-data with multer
- Max file size: 100MB
- Allowed types: CSV, JSON, Excel
- Store in memory (pass to processing pipeline)
- Save to database BYTEA after validation

**Background Processing:**
- In-process task queue (max 5 concurrent jobs)
- Job state tracking in processing_jobs table
- Progress updates: parsing → detecting → mapping → de-identifying → generating
- Error handling: catch all errors, mark job failed, store error message

**Graceful Shutdown:**
- SIGTERM/SIGINT handlers
- Close database connections
- Wait for in-flight requests to complete

**parseIntParam Validation:**
- MANDATORY for all URL parameters
- Use utility from Constitution Section D

**Route Registration Order:**
1. Health endpoint (/health)
2. Specific routes (/auth/login)
3. Parameterized routes (/projects/:id)
4. Catch-all 404

### Agent 7: QA & Deployment

**Health Endpoint Format:**
- Per Constitution Section C: GET /health returns { status: 'ok', timestamp, version }

**Deployment Verification Checklist:**
1. Environment variables set (see section 9)
2. Database migrations run (tsx server/db/migrate.ts)
3. Health endpoint responds 200
4. Login flow works end-to-end
5. File upload and processing completes
6. Download link generates correctly
7. Rate limiting headers present
8. CORS allows frontend origin
9. Error responses match Constitution format

**Testing Priorities:**
1. Authentication flows (register, login, refresh, logout)
2. File upload and parsing (CSV, JSON, Excel)
3. PII detection accuracy (email, phone, SSN patterns)
4. Processing pipeline (end-to-end)
5. Multi-tenant isolation (cannot access other org's data)
6. Rate limiting (verify 429 responses)
7. Error handling (graceful error responses)

**Performance Targets:**
- 1000 records processed in <3 minutes
- Health endpoint responds in <100ms
- Login endpoint responds in <500ms
- File upload (10MB) completes in <30 seconds

---

## ASSUMPTION REGISTER

### AR-001: File Storage Approach (INHERITED FROM PRD)

- **Type:** ASSUMPTION
- **Source Gap:** Executive brief doesn't specify how files are stored (database, filesystem, object storage)
- **Assumption Made:** Files stored in database as BYTEA columns due to Replit's ephemeral filesystem constraint
- **Impact if Wrong:** Database performance issues with large files, may need to refactor to object storage (S3, GCS) if database storage proves problematic
- **Proposed Resolution:** Validate database storage performance with 100MB files on Replit during implementation; consider object storage if database approach has issues
- **Architecture Decision:** Documented in ADR-002 with migration path to Cloudflare R2/S3
- **Status:** ACCEPTED (appropriate for MVP, migration path defined)
- **Owner:** Agent 6 (Implementation Orchestrator)
- **Date:** 2026-01-19

### AR-002: Background Job Queue Implementation (INHERITED FROM PRD)

- **Type:** ASSUMPTION
- **Source Gap:** Executive brief doesn't specify how processing pipeline runs (synchronous, background queue, external worker)
- **Assumption Made:** In-process background queue with simple task scheduling (no dedicated worker infrastructure)
- **Impact if Wrong:** Processing may block other requests if synchronous; may need to add dedicated worker service for better scalability
- **Proposed Resolution:** In-process queue sufficient for MVP (5-10 concurrent jobs); upgrade to BullMQ + Redis if scale demands
- **Architecture Decision:** Documented in ADR-003 with migration path to BullMQ
- **Status:** ACCEPTED (appropriate for MVP, migration path defined)
- **Owner:** Agent 6 (Implementation Orchestrator)
- **Date:** 2026-01-19

### AR-003: PII Detection Algorithm (INHERITED FROM PRD)

- **Type:** ASSUMPTION
- **Source Gap:** Executive brief mentions PII detection but doesn't specify algorithm or accuracy requirements
- **Assumption Made:** Regex-based pattern matching for common PII types (email, phone, SSN) with field name heuristics for detection suggestions
- **Impact if Wrong:** Lower accuracy than expected, may miss PII in unexpected fields or false-positive on non-PII data
- **Proposed Resolution:** Define specific regex patterns and field name matching rules; document accuracy expectations; consider ML-based detection as post-MVP enhancement
- **Architecture Decision:** Processing Engine module with pluggable detectors (extensible to ML later)
- **Status:** UNRESOLVED (requires regex pattern definition in implementation)
- **Owner:** Agent 6 (Implementation Orchestrator)
- **Date:** 2026-01-19

### AR-004: Multi-Organisation Membership (INHERITED FROM PRD)

- **Type:** ASSUMPTION
- **Source Gap:** Executive brief doesn't clarify if users can belong to multiple organisations
- **Assumption Made:** Single organisation per user for MVP (simpler auth context, no organisation switcher needed)
- **Impact if Wrong:** Users who consult for multiple companies cannot access all their projects in one account; may need to add organisation switcher UI and multi-tenancy auth
- **Proposed Resolution:** Confirm with stakeholders during beta if multi-organisation membership is required; add as post-MVP if demand emerges
- **Architecture Decision:** Data model supports one-to-one user-org relationship; JWT includes single organization_id claim
- **Status:** ACCEPTED (appropriate for MVP simplicity)
- **Owner:** Human (Product Decision)
- **Date:** 2026-01-19

### AR-005: Real-Time Progress Tracking Mechanism (INHERITED FROM PRD)

- **Type:** ASSUMPTION
- **Source Gap:** Executive brief requires real-time progress but doesn't specify mechanism
- **Assumption Made:** Polling-based progress tracking (frontend polls backend every 2 seconds during processing)
- **Impact if Wrong:** Inefficient network usage, delayed progress updates, or added complexity if WebSockets required
- **Proposed Resolution:** Polling sufficient for MVP; evaluate WebSockets/SSE if Replit supports and scale demands
- **Architecture Decision:** Documented in ADR-004 with migration path to WebSockets
- **Status:** ACCEPTED (appropriate for MVP, migration path defined)
- **Owner:** Agent 6 (Implementation Orchestrator)
- **Date:** 2026-01-19

### AR-006: Processing Time Achievability (INHERITED FROM PRD)

- **Type:** RISK
- **Source Gap:** Executive brief promises <5 minutes to first dataset, PRD assumes 2-3 minutes for 1000 records
- **Assumption Made:** Processing time target is achievable on Replit infrastructure with optimised pipeline
- **Impact if Wrong:** User experience degraded if processing takes >5 minutes; may lose users during "aha moment" if too slow
- **Proposed Resolution:** Benchmark processing pipeline with realistic data; optimise or adjust targets based on actual performance
- **Architecture Decision:** In-process queue with max 5 concurrent jobs; stream processing for large files
- **Status:** UNRESOLVED (requires performance testing)
- **Owner:** Agent 6 (Implementation Orchestrator)
- **Date:** 2026-01-19

### AR-007: Email Service Provider (INHERITED FROM PRD)

- **Type:** ASSUMPTION
- **Source Gap:** Executive brief mentions invitation emails but doesn't specify email service
- **Assumption Made:** Use OPTIONAL email service (Resend) with graceful degradation (log to console if not configured)
- **Impact if Wrong:** Beta testing blocked if email delivery required but not configured; users cannot accept invitations
- **Proposed Resolution:** Resend API with OPTIONAL classification; log emails in development; manual invitation flow as fallback
- **Architecture Decision:** Email service integration documented in section 8 with fallback strategy
- **Status:** ACCEPTED (Resend selected, graceful degradation specified)
- **Owner:** Agent 6 (Implementation Orchestrator)
- **Date:** 2026-01-19

### AR-008: Teamwork Desk API Version (INHERITED FROM PRD)

- **Type:** ASSUMPTION
- **Source Gap:** Executive brief requires Teamwork Desk integration but doesn't specify API version
- **Assumption Made:** Use current Teamwork Desk REST API (v3 as of Jan 2025)
- **Impact if Wrong:** Integration breaks if Teamwork Desk changes API; may need to support multiple API versions
- **Proposed Resolution:** Document exact API version and endpoints used; monitor Teamwork Desk changelog for deprecation notices
- **Architecture Decision:** Teamwork Desk API v3 integration documented in section 8
- **Status:** UNRESOLVED (requires confirmation of current Teamwork API version)
- **Owner:** Agent 4 (API Contract)
- **Date:** 2026-01-19

### AR-009: Refresh Token Storage

- **Type:** ASSUMPTION
- **Source Gap:** Constitution specifies JWT tokens but doesn't specify refresh token storage mechanism
- **Assumption Made:** Store refresh tokens in database table (refresh_tokens) with user_id, token_hash, expires_at; rotate on use
- **Impact if Wrong:** Refresh tokens cannot be invalidated (logout doesn't work); token reuse attacks possible
- **Proposed Resolution:** Implement refresh token rotation pattern with database storage; invalidate old token on refresh
- **Architecture Decision:** Refresh token management specified in section 5 (Token Management)
- **Status:** RESOLVED (database storage with rotation specified)
- **Owner:** Agent 3 (Data Modeling)
- **Date:** 2026-01-19

### AR-010: Password Reset Token Storage

- **Type:** ASSUMPTION
- **Source Gap:** Password reset flow mentioned but token storage not specified
- **Assumption Made:** Store reset tokens in users table (password_reset_token, password_reset_expires) or separate table; single-use, 1-hour expiry
- **Impact if Wrong:** Password reset doesn't work; tokens can be reused; security vulnerability
- **Proposed Resolution:** Add password_reset_token and password_reset_expires columns to users table; invalidate after successful reset
- **Architecture Decision:** Password reset flow specified in section 5
- **Status:** RESOLVED (users table columns specified)
- **Owner:** Agent 3 (Data Modeling)
- **Date:** 2026-01-19

### AR-011: API Credential Encryption

- **Type:** ASSUMPTION
- **Source Gap:** Teamwork OAuth tokens mentioned but encryption not specified
- **Assumption Made:** Encrypt OAuth tokens with AES-256-GCM before storing in api_credentials table; use ENCRYPTION_KEY environment variable
- **Impact if Wrong:** OAuth tokens stored in plain text; security vulnerability if database compromised
- **Proposed Resolution:** Implement encryption utility (encrypt/decrypt functions) per Constitution Section D; encrypt all sensitive credentials
- **Architecture Decision:** Encryption pattern documented in Agent 2 specification (inherited from Constitution)
- **Status:** RESOLVED (AES-256-GCM encryption specified)
- **Owner:** Agent 6 (Implementation Orchestrator)
- **Date:** 2026-01-19

### AR-012: Processing Job Concurrency Limit

- **Type:** ASSUMPTION
- **Source Gap:** Background processing mentioned but concurrency limits not specified
- **Assumption Made:** Limit to 5 concurrent processing jobs (prevent memory exhaustion on Replit)
- **Impact if Wrong:** Out-of-memory crashes if too many jobs run concurrently; jobs queue indefinitely if limit too low
- **Proposed Resolution:** Start with 5 concurrent jobs; monitor memory usage; adjust based on Replit performance
- **Architecture Decision:** In-process queue with 5 concurrent jobs documented in ADR-003
- **Status:** ACCEPTED (5 concurrent jobs for MVP)
- **Owner:** Agent 6 (Implementation Orchestrator)
- **Date:** 2026-01-19

---

**Document End**
